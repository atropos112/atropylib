{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"atro-core","text":""},{"location":"args/","title":"Atro-Args","text":"<p>Python package that allows one to source arguments from command line arguments, environment variables, environment files and yaml files with overwritable prioritization and decent logging.</p>"},{"location":"args/#installation","title":"Installation","text":"<pre><code>pip install -U atro-args\n</code></pre>"},{"location":"args/#basic-example","title":"Basic Example","text":"<p>Suppose you want to obtain two variables <code>app_name</code> and <code>app_namespace</code> from cli inputs and environment variables. You can do the following:</p> <pre><code>from atro_core.args import Arg, InputArgs\ninput_args = InputArgs(prefix=\"ATRO_TEST\")\ninput_args.add_arg(Arg(name=\"app_name\", arg_type=str, help=\"App name\", required=True))\ninput_args.add_arg(Arg(name=\"app_namespace\", arg_type=str, help=\"App name\", required=True))\n\nmodel = input_args.get_dict()\n</code></pre> <p>The following model will be a dictionary <code>dict</code> which will contain both <code>app_name</code> and <code>app_namespace</code> as keys with their respective values.</p>"},{"location":"args/examples/","title":"Examples","text":"<p>WARNING: This section is a work in progres and in some places it is outdated.</p> <p>Lets first look at a trivial example and explain it along and then provide more complex scenarios</p>"},{"location":"args/examples/#trivial-example","title":"Trivial Example","text":"<p>Consider the following folder structure</p> <pre><code>.\n\u251c\u2500\u2500 main.py\n\u2514\u2500\u2500 temp.yaml\n</code></pre> <p>where <code>temp.yaml</code> has the following contents</p> <pre><code>is_atro_args_example: true\n</code></pre> <p>while <code>main.py</code> has the following contents</p> <pre><code>from atro_core.args import Arg, InputArgs\n\ninput_args = InputArgs()\n\n# Specify source\ninput_args.include_source(\"./temp.yaml\")\n\n# Add arguments\ninput_args.add_arg(\n    Arg(\n        name=\"is_atro_args_example\",\n        arg_type=bool,\n        help=\"Just an example\",\n        required=True,\n    )\n)\n\n# Create model\nmodel = input_args.get_dict()\n</code></pre> <p><code>model</code> in the example above would be <code>model = {'is_atro_args_example': True}</code>.</p> <p>As mentioned above first the InputArgs is instantiated, we then include a source which happens to be the <code>temp.yaml</code> file, this can be passed as a string or a <code>Path</code> type, here I opted for string. I then instruct what argument I want to add, specifying some help, the type I want it to be and insist that it is present, if its missing an ValueError will be raised.</p> <p>Types</p> <p>Below one can see the use of <code>arg_type=int</code> and <code>arg_type=str</code>, other types like <code>bool</code> and <code>float</code> are also supported. In principle even more complex types such as <code>dict</code> and <code>list</code> are supported, but they are rarely good use-case with this package, it is usually better to use <code>yaml</code> or <code>json</code> files for those and load using <code>pyyaml</code> or <code>json</code> instead of this package.</p>"},{"location":"args/examples/#environment-variables","title":"Environment variables","text":"<p>For sake of the example suppose you have (somehow) passed in the environment variables <code>ATRO_TEST_APP_NAME</code> and <code>ATRO_TEST_RANDOM_NUMBER</code> with values <code>test</code> and <code>10</code> respectively.</p> <p>The prefix here is <code>ATRO_TEST</code>. The remaining part of the environment variable must match the \"name\" argument in the Arg part.</p> <pre><code># Setup\nfrom atro_core.args import Arg, InputArgs\n\ninput_args = InputArgs(prefix=\"ATRO_TEST\")\ninput_args.add_arg(Arg(name=\"random_number\", arg_type=int, help=\"Just some random number\", required=True))\ninput_args.add_arg(Arg(name=\"app_name\", arg_type=str, help=\"App name\", required=True))\n\n# Obtain the model (of type dict[str, Any])\nmodel = input_args.get_dict()\n\n# Show that indeed we have the correct values\nassert type(model.get(\"app_name\")) == str\nassert type(model.get(\"random_number\")) == int\n\nassert model.get(\"app_name\") == \"test\"\nassert model.get(\"random_number\") == 10\n</code></pre>"},{"location":"args/examples/#command-line-arguments","title":"Command line arguments","text":"<p>Suppose you have a file called <code>some_file.py</code> with the following contents:</p> <pre><code>from atro_core.args import Arg, InputArgs\n\n# Setup\ninput_args = InputArgs()\ninput_args.add_arg(Arg(name=\"random-number\", arg_type=int, help=\"Just some random number\", required=True))\n\n# Show that indeed we have the correct values\nmodel = input_args.get_dict()\n\nprint(model.get(\"random-number\"))\nif model.get(\"random-number\"):\n  assert type(model.get(\"random-number\")) == int\n</code></pre> <p>If one runs the following command:</p> <pre><code>python some_file.py --random-number 10\n</code></pre> <p>you'd see that the output is <code>10</code> and the assertion passes.</p> <p>If one runs the following command:2</p> <pre><code>python some_file.py --random-number 10.0\n</code></pre> <p>you'd see a <code>ValueError</code> being raised as the type is incorrect.</p>"},{"location":"args/examples/#environment-files","title":"Environment files","text":"<p>For this example suposse we have a file called <code>.env</code> in the same directory where the python file is with the following contents:</p> <pre><code>ATRO_TEST_APP_ENV_FILE_NAME=\"test\"\nATRO_TEST_RANDOM_ENV_FILE_NUMBER=10\n</code></pre> <p>then the following code would work:</p> <pre><code># Setup\nenv_files: list[Path] = [Path(__file__).parent / \".env\"]\ninput_args = InputArgs(prefix=\"ATRO_TEST\", env_files=env_files)\ninput_args.add_arg(Arg(name=\"app_env_file_name\", arg_type=str, help=\"App name\", required=False))\n\n# Create model\nmodel = input_args.get_dict()\n\nassert model.get(\"app_env_file_name\") == \"test\"\n</code></pre> <p>requesting random_env_file_number would also work, but it is not shown here for brevity.</p>"},{"location":"args/examples/#yaml-files","title":"YAML files","text":"<p>Consider the following yaml file (called <code>test.yaml</code>) which is in the same directory as the python file:</p> <pre><code>app_yaml_file_name: \"test\"\nrandom_yaml_file_number: 10\n</code></pre> <p>then the following code would work:</p> <pre><code># Setup\nyaml_files = [Path(__file__).parent / \"test.yaml\"] if provided else []\ninput_args = InputArgs(prefix=\"ATRO_TEST\", yaml_files=yaml_files)\ninput_args.add_arg(Arg(name=\"app_yaml_file_name\", arg_type=str, help=\"App name\", required=False))\n\n# Create model\nmodel = input_args.get_dict()\n\n# Assert\nassert model.get(\"app_yaml_file_name\") == \"test\"\n</code></pre>"},{"location":"args/examples/#populate-class-instance","title":"Populate class instance","text":"<p>We easily can populate a pydantic BaseModel</p>"},{"location":"args/examples/#populate-appsettings","title":"Populate AppSettings","text":"<p>To populate pydantic BaseClass with loaded parameters</p> <pre><code>class Settings(BaseModel):\n    NAME: str\n    HOST: str\n    PORT: int\n    OPTIONAL_PARAMETER: str = \"DEFAULT\"\n    NULLABLE_PARAMETER: Optional[str]\n\napp_settings = InputArgs(prefix=\"MYPREFIX\").populate_cls(Settings, cli_args)\n</code></pre> <p>Work in progress</p> <p>In the future the intention is to use <code>pyyaml</code> and <code>json</code> to load data from yamls and jsons on users behalf along with all the other sources of input. Currently json is not supported and yaml is in its early stages of support.</p>"},{"location":"args/references/","title":"InputArgs","text":"<p>InputArgs is a model that represents the input arguments of an application. After it is initialized the parse_args method can be called to parse the arguments and return them as a dictionary.</p> <p>Attributes:</p> Name Type Description <code>prefix</code> <code>UpperCase</code> <p>The prefix to use for environment variables. Defaults to \"ATRO_ARGS\". This means that the environment variable for the argument \"name\" will be \"ATRO_ARGS_NAME\" and the environment variable for the argument \"other_names\" will be \"ATRO_ARGS_OTHER_NAMES\".</p> <code>args</code> <code>list[Arg]</code> <p>A list of arguments to parse. Defaults to [].</p> <code>sources</code> <code>list[ArgSource | Path]</code> <p>(list[ArgSource], optional): A list of ArgSource enums or paths that represent sources to source arguments from. Defaults to [ArgSource.cli_args, Path(\".env\"), ArgSource.envs]. Order decides the priority in which the arguments are sourced. For example if cli_args is before envs then cli_args will have priority over envs.</p>"},{"location":"args/references/#atro_core.args.input_args.InputArgs.get_dict","title":"get_dict","text":"<pre><code>get_dict(cli_input_args=None)\n</code></pre> <p>Parses the arguments and returns them as a dictionary from (potentially) multiple sources.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from atro_core.args import InputArgs, Arg\n&gt;&gt;&gt; input_arg = InputArgs()\n&gt;&gt;&gt; input_arg.add_arg(Arg(name=\"a\", arg_type=float, help=\"The first addend in the addition.\"))\n&gt;&gt;&gt; input_arg.get_dict()\n{'a': 1.23}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cli_input_args</code> <code>Sequence[str]</code> <p>A list of strings representing the CLI arguments. Defaults to None which means the arguments will be read from sys.argv which is almost always the desired behaviour.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with keys being the argument names and values being the argument values. Argument values will be of the type specified in the Arg model.</p> Source code in <code>atro_core/args/input_args.py</code> <pre><code>def get_dict(self, cli_input_args: Sequence[str] | None = None) -&gt; dict[str, Any]:\n    \"\"\"Parses the arguments and returns them as a dictionary from (potentially) multiple sources.\n\n    Examples:\n        &gt;&gt;&gt; from atro_core.args import InputArgs, Arg\n        &gt;&gt;&gt; input_arg = InputArgs()\n        &gt;&gt;&gt; input_arg.add_arg(Arg(name=\"a\", arg_type=float, help=\"The first addend in the addition.\"))\n        &gt;&gt;&gt; input_arg.get_dict()\n        {'a': 1.23}\n\n    Args:\n        cli_input_args (Sequence[str]): A list of strings representing the CLI arguments. Defaults to None which means the arguments will be read from sys.argv which is almost always the desired behaviour.\n\n    Returns:\n        A dictionary with keys being the argument names and values being the argument values. Argument values will be of the type specified in the Arg model.\n    \"\"\"\n\n    model: dict[str, str] = {}\n\n    for source in self.sources:\n        args = load_source(source, self.prefix, self.args, cli_input_args)\n        model = merge_dicts(\n            model,\n            args,\n            overwrite=False,\n            current_name=source.value if isinstance(source, ArgSource) else source.as_posix(),\n            updating_dict_name=\"args\",\n        )\n\n    model = restrict_keys(model, self.args)\n    typed_model = cast_dict_based_on_args(model, self.args)\n    typed_model = merge_dicts(\n        typed_model,\n        {arg.name: arg.default for arg in self.args},\n        overwrite=False,\n        current_name=\"defaults\",\n        updating_dict_name=\"args\",\n    )\n    throw_if_required_not_populated(typed_model, self.args)\n\n    return typed_model\n</code></pre>"},{"location":"args/references/#atro_core.args.input_args.InputArgs.get_cls","title":"get_cls","text":"<pre><code>get_cls(class_type, cli_input_args=None)\n</code></pre> <p>Parses the arguments and returns them as an instance of the given class with the data populated from (potentially) multiple sources.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; input_args = InputArgs(prefix=\"ATRO_TEST\")\n&gt;&gt;&gt; input_args.set_source(Path(__file__).parent / \".env\")\n&gt;&gt;&gt; resp = input_args.add_cls(TestClassWithUnionType)\n&gt;&gt;&gt; resp = input_args.get_cls(TestClassWithUnionType)\n&gt;&gt;&gt; resp.random_env_file_number\n10\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>class_type</code> <code>type</code> <p>Either a pydantic class or dataclass that we want to populate. Note the arguments have to be added before for this to work, either by .add_cls or by adding arguments one by one.</p> required <code>cli_input_args</code> <code>Sequence[str]</code> <p>A list of strings representing the CLI arguments. Defaults to None which means the arguments will be read from sys.argv which is almost always the desired behaviour.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Instance of the class provided with the fielids populated from potentially multiple sources.</p> Source code in <code>atro_core/args/input_args.py</code> <pre><code>def get_cls(self, class_type: type[T], cli_input_args: Sequence[str] | None = None) -&gt; T:\n    \"\"\"Parses the arguments and returns them as an instance of the given class with the data populated from (potentially) multiple sources.\n\n    Examples:\n        &gt;&gt;&gt; input_args = InputArgs(prefix=\"ATRO_TEST\")\n        &gt;&gt;&gt; input_args.set_source(Path(__file__).parent / \".env\")\n        &gt;&gt;&gt; resp = input_args.add_cls(TestClassWithUnionType)\n        &gt;&gt;&gt; resp = input_args.get_cls(TestClassWithUnionType)\n        &gt;&gt;&gt; resp.random_env_file_number\n        10\n\n    Args:\n        class_type (type): Either a pydantic class or dataclass that we want to populate. Note the arguments have to be added before for this to work, either by .add_cls or by adding arguments one by one.\n        cli_input_args (Sequence[str]): A list of strings representing the CLI arguments. Defaults to None which means the arguments will be read from sys.argv which is almost always the desired behaviour.\n\n    Returns:\n        Instance of the class provided with the fielids populated from potentially multiple sources.\n    \"\"\"\n    typed_dict = self.get_dict(cli_input_args=cli_input_args)\n\n    if is_dataclass(class_type):\n        return get_dataclass(typed_dict, class_type, cli_input_args=cli_input_args)  # type: ignore\n    elif issubclass(class_type, BaseModel):\n        return get_pydantic(typed_dict, class_type, cli_input_args=cli_input_args)  # type: ignore\n    else:\n        raise Exception(f\"Class type '{class_type}' is not supported.\")\n</code></pre>"},{"location":"args/references/#atro_core.args.input_args.InputArgs.populate_cls","title":"populate_cls","text":"<pre><code>populate_cls(class_type, cli_input_args=None)\n</code></pre> <p>Parses the arguments and returns them as an instance of the given class with the data populated from (potentially) multiple sources.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; input_args = InputArgs(prefix=\"ATRO_TEST\")\n&gt;&gt;&gt; input_args.set_source(Path(__file__).parent / \".env\")\n&gt;&gt;&gt; resp = input_args.populate_cls(TestClassWithUnionType)\n&gt;&gt;&gt; resp.random_env_file_number\n10\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>class_type</code> <code>type</code> <p>Either a pydantic class or dataclass that we want to populate.</p> required <code>cli_input_args</code> <code>Sequence[str]</code> <p>A list of strings representing the CLI arguments. Defaults to None which means the arguments will be read from sys.argv which is almost always the desired behaviour.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Instance of the class provided with the fielids populated from potentially multiple sources.</p> Source code in <code>atro_core/args/input_args.py</code> <pre><code>def populate_cls(self, class_type: type[T], cli_input_args: Sequence[str] | None = None) -&gt; T:\n    \"\"\"Parses the arguments and returns them as an instance of the given class with the data populated from (potentially) multiple sources.\n\n    Examples:\n        &gt;&gt;&gt; input_args = InputArgs(prefix=\"ATRO_TEST\")\n        &gt;&gt;&gt; input_args.set_source(Path(__file__).parent / \".env\")\n        &gt;&gt;&gt; resp = input_args.populate_cls(TestClassWithUnionType)\n        &gt;&gt;&gt; resp.random_env_file_number\n        10\n\n    Args:\n        class_type (type): Either a pydantic class or dataclass that we want to populate.\n        cli_input_args (Sequence[str]): A list of strings representing the CLI arguments. Defaults to None which means the arguments will be read from sys.argv which is almost always the desired behaviour.\n\n    Returns:\n        Instance of the class provided with the fielids populated from potentially multiple sources.\n    \"\"\"\n    self.add_cls(class_type)\n    return self.get_cls(class_type, cli_input_args=cli_input_args)\n</code></pre>"},{"location":"args/references/#arg","title":"Arg","text":"<p>Arg is a model that represents a single argument that can be passed to a program via CLI, ENV, ENV file or Yaml file.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the argument. This is the key that will be used to access the value of the argument.</p> <code>other_names</code> <code>list[str]</code> <p>Other names that can be used to access the value of the argument. Defaults to [].</p> <code>arg_type</code> <code>type</code> <p>The type of the argument. Defaults to str. Possible values are: str, int, float, bool, list, dict, no generic typing allowed, e.g. list[str] is not allowed.</p> <code>help</code> <code>str</code> <p>The help text for the argument. Defaults to \"\".</p> <code>required</code> <code>bool</code> <p>Whether the argument is required. Defaults to True.</p> <code>default</code> <code>Any</code> <p>The default value of the argument. If set to None it is assumed there is no default (will fail on required=True). Defaults to None.</p>"},{"location":"args/references/#argsource","title":"ArgSource","text":"<p>Enum for the non-file source of an argument. This doesn't included sources that are file based.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The value of the enum. Possible choices are \"cli\" or \"envs\".</p>"},{"location":"args/usage/","title":"Usage","text":"<p>At its core, usage of atro-args should be very simple, you instantiate a class, instruct it where to get the configs from and what configs to get, thats it.</p>"},{"location":"args/usage/#including-sources","title":"Including sources","text":"<p>In order to get the data, we need to know sources to get this data from. By default atro-args looks at cli-arguments, <code>.env</code> file and environment variables with given prefix, if no prefix is provided at instantiation of InputArgs a default prefix of <code>ATRO_ARGS</code> is used.</p> <p>Sources are a list of either strings or of type Path (from pathlib). If a path is provided it is expected to point to a file that contains the needed data, currently <code>ini, yaml, json, toml, env</code> are the only supported file formats, any other format will raise an exception.</p> <p>If a string is provided it is first checked if it happens to be one of 2 special strings, <code>cli</code> or <code>envs</code>, <code>cli</code> refers to cli arguments, while <code>envs</code> refers to environment variables. If its neither <code>cli</code> or <code>envs</code> an attempt is made to interpret it as a path to a file as above, if this fails an exception is raised.</p> <p>Do note the order of elements in sources matters, first on the list is prioritied over the rest, if the same variable appears in two places it is not overwritten. Because of this you may want to replace the defaults entirely, this can be done with the <code>set_source</code> and <code>set_sources</code> functions. If instead you simply want to add more sources this can be done with <code>include_source</code> and <code>include_sources</code> or simply <code>include</code>.</p> <p>In total there are 3 ways to include args,</p> <ul> <li>Via sources parameter during <code>InputArgs</code> instance initialisation</li> <li>Via <code>include_source</code> passing either a string or a path, a stiring can be either a path representation, \"cli\" or \"envs\".</li> <li>Via <code>include_sources</code> passing a list of elements. Each element is either a string or a path, a stiring can be either a path representation, \"cli\" or \"envs\".</li> </ul>"},{"location":"args/usage/#adding-arguments","title":"Adding arguments","text":"<p>Adding arguments should tell the package what arguments you expect to obtain from the sources provided. Note you do not have to provide sources first and then arguments, as long as they are both provided before reconciliations (via say <code>get_dict()</code> function). Arguments can be added via <code>add_arg</code>, <code>add_args</code> or <code>add</code>, note <code>add</code> is just an alias to <code>add_arg</code>. You can also create a dataclass or a pydantic class and add that class, this will add all of that classes public properties as arguments.</p> <p>In total there are 5 ways of providing arguments</p> <ul> <li>Via args parameter during <code>InputArgs</code> instance initialisation</li> <li>Via <code>include_arg</code> on <code>InputArgs</code> instance, passing a single <code>Arg</code> element.</li> <li>Via <code>include_args</code> on <code>InputArgs</code> instance, passing a list of <code>Arg</code> elements</li> <li>Via <code>add</code> on <code>InputsArgs</code> instance, passing params that would be typically passed into Arg (this is purely for convenience).</li> <li>Via <code>add_cls</code> on <code>InputArgs</code> instance, passing a class that is either a dataclass or pydantic class, public properties are then added as arguments.</li> </ul>"},{"location":"args/usage/#getting-the-config","title":"Getting the config","text":"<p>Assuming we now have an instance of <code>InputArgs</code> with correct arguments added and sources included we can now get the data back in multiple ways, depending what is convinient.</p> <p>We can call <code>get_dict()</code> to get a dictionary with keys being the names of arguments provided, while the values will be the sourced configuration values form the sources provided.</p> <p>We can also do <code>get_cls(...)</code> which takes the class type as an input and outputs an instance of that class with its parameters populated. Note this is only supported for data classes and pydantic classes.</p> <p>By far shortes way of using this package is to use <code>populate_cls()</code> where a class type is provided and populated on the spot. All one has to do is instantiate <code>InputArgs</code> with correct prefix and sources, and call <code>populate_cls()</code> on it and that is it, this is of course not as flexible as the methods above so it may not be good for every use-case.</p> <p>In addition to the above we can also decorate a function to take inputs from the config, look at examples section for examples how this is done.</p>"}]}